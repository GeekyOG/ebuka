const http = require( "http" );
const path = require( "path" );
const conf = require( "./config/defaultConfig" );
const route = require( "./helper/route.js" );
const open = require( "./helper/openUrl.js" );

class Server{
	constructor( config ) {
		this.conf = Object.assign( {} , conf , config );
	}
	start() {
		// http.createServer([requestListener])
		// 返回一个新建的http.Server实例.requestListener是一个函数,会被自动添加到'request'事件
		// 'request' 事件:
		// 每次接收到一个请求时触发,注意,每个连接可能有多个请求
		// (在 HTTP keep-alive 连接的情况下)
		// 接收两个参数1:request请求对象,可以拿到请求的信息,2:response响应对象,给请求发送响应
		const server = http.createServer( ( req , res ) => {
				const filePath = path.join( this.conf.root , req.url );
				// console.log( this.conf.root );	// process.cwd()
				// console.log( req.url );		// 请求路径
				route( req , res , filePath , this.conf );
		} );
		server.listen( this.conf.port , this.conf.hostname , () => {
				open( `http://${this.conf.hostname}:${this.conf.port}` );
				console.info( `server is running in http://${this.conf.hostname}:${this.conf.port}` );


		} );
	}
};
module.exports = Server;
// Object.assign 方法只复制源对象中可枚举的属性和对象自身的属性.

// path.join([... paths]),// ...paths <字符串>一个路径片段的序列
// 返回 <string>
// path.join()使用方法特定平台个人文库的分隔符把全部给定的path片段连接到一起,
// 并规范化生成的路径。
// 长度为零的path,片段会被忽略如果连接后的路径字符串是一个长度为零的字符串,
// 则返回'.'，表示当前工作目录.
// path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');
// 返回: '/foo/bar/baz/asdf'

// path.join('foo', {}, 'bar');
// 抛出 'TypeError: Path must be a string. Received {}'
// 如果任一路径片段不是一个字符串,则抛出TypeError.


// ES7的语法标准,async一般修饰一个函数,说明这个函数是异步的.
// await一般是用来执行异步操作的,很多情况下它的后面会跟着Promise对象

// async和await提出的意义在于:用同步的方式处理异步~!
// 基本概念:
// async 表示这是一个async函数,await只能用在这个函数里面.
//		async 对象也是一个 promise 对象.
// await 表示在这里等待promise返回结果了,再继续执行.
// await 后面跟着的应该是一个promise对象(当然,其他返回值也没关系,不过那样就没意义)
// (所谓Promise,简单说就是一个容器,里面保存着某个未来才会结束的事件
// (通常是一个异步操作)的结果.从语法上说,Promise是一个对象,从它可以获取异步操作的消息.
// Promise 提供统一的 API,各种异步操作都可以用同样的方法进行处理.)

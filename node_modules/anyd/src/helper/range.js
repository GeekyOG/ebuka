// 什么是Range？
//	当用户在听一首歌的时候,如果听到一半(网络下载了一半),网络断掉,用户需要继续听的时候,文件服务器不支持断点的话,则用户需要重新下载这个文件.
//	而Range支持的话,客户端应该记录了之前已经读取的文件范围,网络恢复之后,则向服务器发送读取剩余Range的请求,服务端只需要发送客户端请求的那部分内容,而不用整个文件发送回客户端,以此节省网络带宽.
//		一般处理单线程处理:客户端发来请求——->服务端返回200——>客户端开始接受数据——>用户把下载停止了——>客户端突然停止接受数据——>然后客户端与服务端断开了——>用户手的痒了又按回开始键——>客户端再次与服务端连接上,
//		并发送Range请求头给服务端——>这时服务端返回是206——>服务端从断开的数据那继续发送,并且会发送响应头:Content-Range给客户端 ——>客户端接收数据 ——>直到完成.
//	如果Server支持Range,首先就要告诉客户端,咱支持Range,之后客户端才可能发起带Range的请求.response.setHeader( 'Accept-Ranges' , 'bytes' );
//	Server通过请求头中的Range: bytes = 0-xxx来判断是否是做Range请求,如果这个值存在而且有效,则只发回请求的那部分文件内容,如果服务器能够正常响应的话,服务器会返回 206 Partial Content 的状态码及说明
//	并设置Content-Range.如果无效,则返回416状态码,表明Request Range Not Satisfiable(http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.17),
//	如果不包含Range的请求头，则继续通过常规的方式响应。

// 流程如下:
//	1:浏览器请求内容.
//	2:服务器告诉浏览器,该内容可以使用 Accept-Ranges消息头进行分部分请求.
//	3:浏览器重新发送请求,用 Range 消息头告诉服务器需要的内容范围.
//	服务器会分如下两种情况响应浏览器的请求:
//		如果范围是合理的,服务器会返回所请求的部分内容,并带上 206 Partial Content 状态码.当前内容的范围会在 Content-Range 消息头中申明.
//		如果范围是不可用的(例如,比内容的总字节数大),服务器会返回 416 请求范围不合理 Requested Range Not Satisfiable 状态码,可用的范围也会在 Content-Range 消息头中声明.
// range:bytes=[start]~[end]
//	Range 请求头格式Range: 字节数（bytes）=(开始)-(结束)
//	这是浏览器告知服务器所需分部分内容范围的消息头.注意开始和结束位置是都包括在内的,这个消息头也可以不发送两个位置,其含义如下:
//	如果结束位置被去掉了,服务器会返回从声明的开始位置到整个内容的结束位置内容的最后一个可用字节.
//	如果开始位置被去掉了,结束位置参数可以被描述成从最后一个可用的字节算起可以被服务器返回的字节数.(仅在请求最后一次数据时使用的情况)
//	Range: bytes=10- :第10个字节及最后个字节的数据
//	Range: bytes=40-100 :第40个字节到第100个字节之间的数据
//	注意,这个表示[start,end],即是包含请求头的start及end字节的,所以,下一个请求,应该是上一个请求的[end+1, nextEnd]
// Accept-Rangs:bytes
//	Accept-Ranges: 字节（bytes）
//	这是会由服务器发送的字节头，展示可以被分部分发送给浏览器的内容. 这个值声明了可被接受的每一个范围请求,大多数情况下是字节数 bytes.
// Content-Range:bytes start~end/total
//	响应头Content-Range
//	Content-Range: bytes 0-10/3103,这个表示,服务器响应了前(0-10)个字节的数据,该资源一共有(3103)个字节大小.

module.exports = ( totalSize , req , res ) => {
		const range = req.headers[ 'range' ];
		if( !range ) return { code : 200 };
		const sizes = range.match( /bytes=(\d*)-(\d*)/ );	// 100-300,totalSize:1000 *正则可有可无
		const end = sizes[ 2 ] || totalSize - 1;	// 300 || 1000-1=999(0开头的所以小一位)
		const start = sizes[ 1 ] || totalSize - end;	// 100 || 1000-300=700
		if( start > end || start < 0 || end > totalSize ) return {code : 200}
		res.setHeader( 'Accept-Ranges' , 'bytes' );	// 响应头加上表示服务器可以处理range
		res.setHeader( 'Content-Range' , `bytes ${start}-${end}/${totalSize}` );
		res.setHeader( 'Content-Length' , end - start );
		return {
				code : 206,
				start : parseInt( start ),
				end : parseInt( end )
		};
};




const fs = require( "fs" );
const path = require( "path" );
const Handlebars = require( "handlebars" );	// 模板引擎
const promisify = require( "util" ).promisify;	// 异步处理
// const config = require( "../config/defaultConfig.js" );	// 配置(通过参数传递)
const mime = require( "./mime.js" );	// mime类型
const compress = require( "./compress.js" );	// 压缩
const range = require( "./range.js" );	// 断点处理
const isFresh = require( "./cache.js" );	// cache
const stat = promisify( fs.stat );
const readdir = promisify( fs.readdir );
const tplPath = path.join( __dirname , "../template/dir.tpl" );	// 拼接dir.tpl文件绝对路径(获取其它文件绝对路径)
const template = Handlebars.compile( fs.readFileSync( tplPath ).toString() );	// 编译,同步读文件并转化buffer
module.exports = async function( req , res , filePath , config ) {	// filePath是用户process.cwd()和请求路径的拼接
		try {
				const stats = await stat( filePath );
				if( stats.isFile() ) {	// 为文件
						const type = mime( filePath );
						res.setHeader( "Content-Type" , type );
						if( isFresh( stats , req , res ) ) {
							res.statusCode = 304;
							res.end();
							return;
						};
						let rs;
						const {code , start , end} = range( stats.size , req , res );
						if( code === 200 ) {
								res.statusCode = 200;
								rs = fs.createReadStream( filePath );	// 读文件流
						} else {
								res.statusCode = 206;
								rs = fs.createReadStream( filePath , { start , end } );// range文件流
						};
						if( filePath.match( config.compress ) ) rs = compress( rs , req , res );	// 压缩流
						rs.pipe( res );	//pipe( res )?
				} else if( stats.isDirectory() ) {	// 为文件夹
						const files = await readdir( filePath );
						res.statusCode = 200;
						res.setHeader( "Content-Type" , "text/html" );
						const dir = path.relative( config.root , filePath );// 取filePath(当前路径)相对根目录的相对路径
						const data = {
							files : files.map( file => ( { file,icon : mime( file ) } ) ),// 箭头函数返回对象
							title : path.basename( filePath ),	// basename 返回文件全名(url末尾的文件全名)
							dir : dir ? `/${dir}` : "",	// 加'/'代表从根路径开始,避免直接在URL后拼接产生错误(在根路径时dir为空则不加'/')
						};	// files!es6属性名和属性值相同可以这样简写
						res.end( template( data ) );	// 输入变量
				};
		} catch( error ) {
				console.error( error );
				res.statusCode = 404;
				res.setHeader( "Content-Type" , "text/plain" );
				res.end( `${filePath} is not a directory or file\n${error.toString()}` );
		};
};
// path.relative( from , to )from <string>,to <string>
// 返回:<string>
// path.relative() 方法返回从from(para1)到to(para2)的相对路径(基于当前工作目录),
// 如果 from 和 to 各自解析到同一路径(调用 path.resolve()),则返回一个长度为零的字符串.
// 如果 from 或 to 传入了一个长度为零的字符串,则当前工作目录会被用于代替长度为零的字符串.

// 使用Handlebars.compile()方法来预编译模板

// Handlebars expressions 是handlebars模板中最基本的单元,使用方法是加两个花括号{{value}},
// handlebars模板会自动匹配相应的数值,对象甚至是函数.

// 使用内置的{{#each}} helper遍历列表块内容,用this来引用遍历的元素
// 使用#each会直接进入到对象中去,不用写obj.key,直接可以写key

/*
						(已经失效)---------------->(判断文件hash或是文件修改时间和服务器修改时间有无变化)---->(没有变化)---->(没有变化,返回状态码304,并更新过期时间)--->不返回实体内容
							^																	|
							|																	|
(发请求判断检查是否失效(通过last-Modified以及Etag和Expires等))-->(没有失效)-->使用本地缓存			|
							^																	|
							|																	|
						(存在缓存)															(已经变化)
							^																	|
							|																	|
用户发起请求-->浏览器检查会本地是否存在缓存-->(没有缓存)-->发起请求(包含last-Modified以及Etag和Expires等字段并带有文件hash或是文件修改时间的标识)-->服务器协商缓存内容并返回响应-->浏览器将缓存放置在本地

常用的与缓存有关的 HTTP 消息报头
消息报头						值							类型					作用														规则
Status Code			200 OK								普通			表明服务器成功返回网页												不适用
					304 Not Modified					普通			表明当前资源的内容(自上次访问以来或根据请求的条件)没有修改过,服务器不返回网页内容	不适用
Cache-Control		max-age=315360000					响应			指明缓冲副本的有效时长,单位为秒											新鲜度
Expires				Thu,31 Dec 2037 23:55:55 GMT		响应			告诉浏览器在过期时间前可以使用副本										新鲜度
Last-Modified		Sun, 23 Oct 2016 06:36:08 GMT		响应			告诉浏览器当前资源的最近一次修改时间										新鲜度
If-Modified-Since	Sun, 23 Oct 2016 06:36:08 GMT		请求			如果浏览器第一次请求时响应中 Last-Modified 非空,							新鲜度
																	第二次请求同一资源时，会把它作为该项的值发给服务器
ETag					978534							响应			告诉浏览器当前资源在服务器的唯一标识符(生成规则由服务器决定)					校验值
If-None-Match			978534							请求			如果浏览器第一次请求时响应中 ETag 非空,第二次请求同一资源时,					校验值
																	会把它作为该项的值发给服务器


用户操作行为与缓存:
	用户在使用浏览器的时的各种操作,如输入地址后回车,按F5刷新等,对缓存有可能会造成影响.
	用户操作				Expires/Cache-Controll				Last-Modified/ETag
	地址栏回车						有效									有效
	页面链接跳转					有效									有效
	新开窗口						有效									有效
	前进后退						有效									有效
	F5 刷新						无效									有效
	Ctrl+F5 强制刷新				无效									无效
	当用户在按 F5 进行刷新时,浏览器会忽略 Expires/Cache-Control 的设置,再次向服务器发送请求,
	而 Last-Modified/Etag 仍然是有效的,服务器会根据情况判断返回 304 还是 200;
	而当用户使用 Ctrl+F5 进行强制刷新的时候,所有的缓存机制都将失效;浏览器将重新从服务器下载资源并返回 200
*/
// 判断本地是否失效Expires,Cache-Control
// 判断文件修改时间If-Modified-Since(将服务器上次返回的修改时间放在req中)/Last-Modified(服务器校验后返回上次修改的时间).
// 判断文件修改时间2:If-None-Match/ETag(使用hash算法来进行比对)

const{ cache } = require( "../config/defaultConfig.js" )
// para :修改时间,para2:响应头
const refreshRes = ( stats , res ) => {
		const{ maxAge , expires , cacheControl , lastModified , etag } = cache;
		if( expires ) res.setHeader( "Expires" , new Date( Date.now() + maxAge * 1000 ).toUTCString() );
		if( cacheControl ) res.setHeader( "Cache-Control" , `public, max-age=${maxAge}` );
		if( lastModified ) res.setHeader( "Last-Modified" , stats.mtime.toUTCString() );
	//	if( etag ) res.setHeader( "ETag" , `${stats.size}-${stats.mtime}` );	// 生成hash
};

module.exports = function isFresh( stats , req , res ) {
		refreshRes( stats , res );
		const lastModified = req.headers[ "if-modified-since" ];
		const etag = req.headers[ "if-none-match" ];
		if( !lastModified && !etag ) return false;	// 第一次请求
		if( lastModified && lastModified !== res.getHeader( "Last-Modified" ) ) return false;
	//	if( etag && etag !== res.getHeader( "ETag" ) ) return false;
		return true;
};

// Date.now()返回值1970 年 1 月 1日午夜与当前日期和时间之间的毫秒数.
// new Date()传入毫秒数返回时间

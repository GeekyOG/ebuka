<!DOCTYPE html>
<html>
	<head>
		<meta charset="{CHARSET}">
		<title></title>
	</head>
	<body>
		<script type = "text/javascript" charset = "utf-8">
				// ES6 原生提供了 Promise 对象.
				// 所谓 Promise,就是一个对象,用来传递异步操作的消息.它代表了某个未来才会知道结果的事件(通常是一个异步操作),并且这个事件提供统一的 API,可供进一步处理.
				// Promise 对象有以下两个特点:
				// 1: 对象的状态不受外界影响,Promise 对象代表一个异步操作,有三种状态：Pending(进行中),Resolved(已完成,又称 Fulfilled)和 Rejected(已失败),
				//		只有异步操作的结果，可以决定当前是哪一种状态,任何其他操作都无法改变这个状态.这也是 Promise 这个名字的由来,它的英语意思就是[承诺],表示其他手段无法改变.
				// 2: 一旦状态改变,就不会再变,任何时候都可以得到这个结果.Promise 对象的状态改变,只有两种可能:从 Pending 变为 Resolved 和从 Pending 变为 Rejected.
				//		只要这两种情况发生,状态就凝固了,不会再变了,会一直保持这个结果.就算改变已经发生了,你再对 Promise 对象添加回调函数,也会立即得到这个结果.
				//		这与事件(Event)完全不同,事件的特点是,如果你错过了它.再去监听,是得不到结果的.
				
				// 注意！只new了一个对象,并没有调用它,我们传进去的函数就已经执行了,这是需要注意的一个细节.所以我们用Promise的时候一般是包在一个函数中,在需要的时候去运行这个函数,如:
				function runAsync() {
						var p = new Promise( function( resolve , reject ) {// 两个参数：resolve,reject,分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数
								// 异步操作
								setTimeout( function() {
										console.log( '执行完成' );
										resolve( '随便什么数据' );
								} , 2000 );
						} );
						return p;// return出Promise对象
				};
				runAsync().then( function( data ) {// 在这里then接收一个参数,是函数,并会拿到在runAsync中调用resolve时传的的参数,运行代码,会在2秒后输出“执行完成”,紧接着输出“随便什么数据”
						console.log( data );
				} );
				// 链式操作用法类似:
				function runAsync1() {
						var p = new Promise( function( resolve , reject ) {
								//做一些异步操作
								setTimeout( function() {
										console.log( '异步任务1执行完成' );
										resolve( '随便什么数据1' );
								} , 1000);
						} );
						return p;
				};
				function runAsync2() {
						var p = new Promise( function( resolve , reject ) {
								//做一些异步操作
								setTimeout( function() {
										console.log( '异步任务2执行完成' );
										resolve( '随便什么数据2' );
								} , 2000);
						} );
						return p;
				};
				function runAsync3() {
						var p = new Promise( function( resolve , reject ) {
								//做一些异步操作
								setTimeout( function() {
										console.log( '异步任务3执行完成' );
										resolve( '随便什么数据3' );
								} , 3000);
						} );
						return p;
				};
				runAsync1().then( function( data ) {
						console.log( data );
						return runAsync2();
				} ).then( function( data ) {
						console.log( data );
						return runAsync3();
				} ).then( function( data ) {
						console.log( data );
				} );
				// reject的用法:
				// getNumber函数用来异步获取一个数字,2秒后执行完成,如果数字小于等于5,我们认为是“成功”,调用resolve修改Promise的状态.否则我们认为是“失败”了,调用reject并传递一个参数,作为失败的原因.
				function getNumber(){
						var p = new Promise( function( resolve , reject ) {
								//做一些异步操作
								setTimeout( function() {
										var num = Math.ceil( Math.random() * 10 ); //生成1-10的随机数
										if( num <= 5 ) resolve( num );
										else reject( '数字太大了' );
								} , 2000 );
						} );
						return p;
				};
				getNumber().then( function( data ) {// then方法可以接受两个参数,第一个对应resolve的回调,第二个对应reject的回调.能够分别拿到他们传过来的数据
						console.log( 'resolved' );
						console.log( data );
				},
				function( reason , data ) {
						console.log('rejected');
						console.log(reason);
				} );
				// catch的用法:其实它和then的第二个参数一样,用来指定reject的回调,用法如下
				getNumber().then( function( data ) {
						console.log( 'resolved' );
						console.log( data );
				} ).catch( function( reason ) {
						console.log( 'rejected' );
						console.log( reason );
				} );
				// 不过catch还有另外一个作用:在执行resolve的回调(也就是上面then中的第一个参数)时,如果抛出异常了(代码出错了),那么并不会报错卡死js,而是会进到这个catch方法中,如下
				getNumber().then( function( data ) {
						console.log( 'resolved' );
						console.log( data );
						console.log( somedata ); //此处的somedata未定义会进到catch方法里面去了,而且把错误原因传到了reason参数中.即便是有错误的代码也不会报错了
				} ).catch( function( reason ) {
						console.log( 'rejected' );
						console.log( reason );
				} );
				// all的用法(并行执行异步操作的能力)all方法的效果实际上是「谁跑的慢,以谁为准执行回调」
				// 有了all,你就可以并行执行多个异步操作,并且在一个回调中处理所有的返回数据,有一个场景是很适合用这个的,一些游戏类的素材比较多的应用,
				// 打开网页时,预先加载需要用到的各种资源如图片,flash以及各种静态文件.所有的都加载完后,我们再进行页面的初始化.
				Promise.all( [ runAsync1() , runAsync2() , runAsync3() ] ).then( function( results ) { //all接收一个数组参数,里面的值最终都算返回Promise对象.
																									// 三个异步操作的并行执行的,等到它们都执行完后才会进到then里面.
																									// 那么,三个异步操作返回的数据哪里去了呢?都在then里面呢,
																									// all会把所有异步操作的结果放进一个数组中传给then,就是上面的results.
						console.log( "all返回:" + results );
				} );
				// race的用法:和all方法的效果相对的另一个方法「谁跑的快，以谁为准执行回调」
				Promise.race( [ runAsync1() , runAsync2() , runAsync3() ] ).then( function( results ) {// 这三个异步操作同样是并行执行的,结果是1秒后runAsync1已经执行完了,
																									// 此时then里面的就执行了.在then里面的回调开始执行时,
																									// runAsync2()和runAsync3()并没有停止,仍旧再执行.于是再过1秒后,输出了他们结束的标志
						console.log( "race返回:" + results );
				} );
		</script>
	</body>
</html>
